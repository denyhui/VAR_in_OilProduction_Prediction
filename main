from __future__ import absolute_import
# GUI
import tkinter
from tkinter import ttk
import tkinter.messagebox
# basic
import numpy as np
import pandas as pd
import numpy.linalg as la
from sklearn.metrics import r2_score, mean_absolute_error
import scipy
from statsmodels.tsa.vector_ar.var_model import VAR
from statsmodels.compat.python import iteritems, StringIO, lrange
from statsmodels.iolib import SimpleTable
import statsmodels.tsa.vector_ar.util as util
from statsmodels.tools.tools import chain_dot
# plotting
import matplotlib.pyplot as plt

# util
import re
import os
import tqdm
from collections import defaultdict
from functools import partial
from util import m_assert_error, forecast_interval

plt.rcParams['font.sans-serif'] = ['SimHei']  # 解决中文显示问题-设置字体为黑体
plt.rcParams['axes.unicode_minus'] = False  # 解决保存图像是负号'-'显示为方块的问题


class window:
    def __init__(self):
        np.random.seed(1)
        self.Pdata = None
        self.Idata = None
        self.total = None
        self.result = None
        self.model = None
        self.root = tkinter.Tk()
        self.root.title('产量预测应用')
        self.root.geometry('480x490')

        self.tabcontrol = ttk.Notebook(self.root)
        self.tab1 = ttk.Frame(self.tabcontrol)
        self.tabcontrol.add(self.tab1, text='输入')
        self.tab2 = ttk.Frame(self.tabcontrol)
        self.tabcontrol.add(self.tab2, text='滞后阶数分析')
        self.tabcontrol.grid()

        self.read_frm = ttk.Frame(self.tab1)
        tkinter.Label(self.read_frm, text='输入参数', fg='blue').grid(row=0, column=0, sticky=tkinter.W)
        tkinter.Label(self.read_frm, text='表格内年月表头').grid(row=1, column=0)
        self.P_cl_1 = ttk.Combobox(self.read_frm)
        self.P_cl_1.grid(row=2, column=0)
        self.P_cl_1['state'] = 'readonly'
        tkinter.Label(self.read_frm, text='表格内井号表头').grid(row=3, column=0)
        self.P_cl_2 = ttk.Combobox(self.read_frm)
        self.P_cl_2.grid(row=4, column=0)
        self.P_cl_2['state'] = 'readonly'
        tkinter.Label(self.read_frm, text='表格内单位时间产量表头').grid(row=5, column=0)
        self.P_cl_3 = ttk.Combobox(self.read_frm)
        self.P_cl_3.grid(row=6, column=0)
        self.P_cl_3['state'] = 'readonly'

        tkinter.Button(self.read_frm, text='读取采出井数据', command=self.read_csv_P).grid(row=7, column=0)

        tkinter.Label(self.read_frm, text='表格内年月表头').grid(row=1, column=1)
        self.I_cl_1 = ttk.Combobox(self.read_frm)
        self.I_cl_1.grid(row=2, column=1)
        self.I_cl_1['state'] = 'readonly'
        tkinter.Label(self.read_frm, text='表格内井号表头').grid(row=3, column=1)
        self.I_cl_2 = ttk.Combobox(self.read_frm)
        self.I_cl_2.grid(row=4, column=1)
        self.I_cl_2['state'] = 'readonly'
        tkinter.Label(self.read_frm, text='表格内单位时间注入量表头').grid(row=5, column=1)
        self.I_cl_3 = ttk.Combobox(self.read_frm)
        self.I_cl_3.grid(row=6, column=1)
        self.I_cl_3['state'] = 'readonly'
        tkinter.Button(self.read_frm, text='读取注入井数据', command=self.read_csv_I).grid(row=7, column=1)

        self.aux_frm = tkinter.Frame(self.tab1)

        self.lag_command = tkinter.Button(self.aux_frm, text='滞后阶数分析', command=self.maxlag_selection, width=10,
                                          state=tkinter.DISABLED)
        self.lag_command.grid(row=4, column=0, sticky=tkinter.W)

        self.validate_command = tkinter.Button(self.aux_frm, text='拟合并且验证', command=self.fit_and_validate, width=10,
                                               state=tkinter.DISABLED)
        self.validate_command.grid(row=4, column=1, sticky=tkinter.W)

        self.predict_command = tkinter.Button(self.aux_frm, text='拟合并且预测', command=self.fit_and_predict, width=10,
                                              state=tkinter.DISABLED)
        self.predict_command.grid(row=4, column=2, sticky=tkinter.W)

        tkinter.Label(self.aux_frm, text='拟合结果显示', fg='blue').grid(row=6)
        self.verbose_list = tkinter.Listbox(self.aux_frm, width=45, height=4)
        self.verbose_list.grid(row=7, column=0, columnspan=4)

        tkinter.Label(self.aux_frm, text='滞后阶数', ).grid(row=1, column=0, sticky=tkinter.W)
        self.Lag_cl = ttk.Combobox(self.aux_frm)
        self.Lag_cl.grid(row=2, column=0, columnspan=2)
        self.Lag_cl['values'] = list(range(1, 25))
        self.Lag_cl.current(0)
        self.Lag_cl['state'] = 'readonly'

        def new_root_permission():
            self.new_button['state'] = tkinter.NORMAL if self.v2.get() else tkinter.DISABLED

        self.v2 = tkinter.IntVar()
        self.v2.set(0)
        tkinter.Checkbutton(self.aux_frm, text='使用注入井数据', variable=self.v2, command=new_root_permission).grid(row=3,
                                                                                                              column=0)
        self.v3 = tkinter.IntVar()
        self.v3.set(0)
        tkinter.Checkbutton(self.aux_frm, text='预测不确定性', variable=self.v3, ).grid(row=3, column=1)

        self.new_button = tkinter.Button(self.aux_frm, text='脉冲响应分析', command=self.m_irf, state=tkinter.DISABLED,
                                         width=10, )
        self.new_button.grid(row=4, column=3, sticky=tkinter.W)

        tkinter.Label(self.aux_frm, text='跳过时间步数', ).grid(row=1, column=2, sticky=tkinter.W)
        self.year_cl = ttk.Combobox(self.aux_frm)
        self.year_cl['values'] = list(range(300))
        self.year_cl.current(0)
        self.year_cl['state'] = 'readonly'
        self.year_cl.grid(row=2, column=2, columnspan=2)

        self.Info_frm = tkinter.Frame(self.tab2)
        tkinter.Label(self.Info_frm, text='分析结果', fg='blue').grid(sticky=tkinter.W)
        self.InfoText = tkinter.Text(self.Info_frm, width=60, height=30)
        self.InfoText.grid()
        self.Info_frm.grid(row=0, column=1, ipadx=10, ipady=10, padx=10, pady=10, rowspan=2)

        self.read_frm.grid(row=0, column=0)
        self.aux_frm.grid(ipady=10, pady=10, row=1, column=0, )

        def get_help():
            temp_info = '''
            该应用的输入为带有井名，日期，日产量或月产量的数据，注入井数据为可选输入;
            如果未能自动识别读取文件中的输入数据，需要用户自行设置需读取数据的表头;
            读取成功后，用户可自行选择预测函数的滞后阶数，拟合原理详见用户手册;
            用户也可通过滞后阶数分析选项选取最优滞后阶数;
            在拟合完成后可进行脉冲响应分析，该选项可分析注入井对采出井的影响程度;
            '''
            tkinter.messagebox.showinfo('帮助', temp_info)

        menu_bar = tkinter.Menu(self.root)
        self.root.config(menu=menu_bar)
        help_menu = tkinter.Menu(menu_bar, tearoff=0)
        help_menu.add_command(label="关于", command=get_help)
        menu_bar.add_cascade(label="帮助", menu=help_menu)

        self.root.mainloop()

    def read_csv_P(self, ):
        '''
        读取采出井报告数据,若其中包含年月,井号,日采油量等表头则设为默认表头
        :return:
        '''
        from util import _read
        self.Pdata = _read()
        col = list(self.Pdata.columns)
        self.P_cl_1['values'] = col
        self.P_cl_2['values'] = col
        self.P_cl_3['values'] = col
        try:
            self.P_cl_1.current(col.index('年月'))
            self.P_cl_2.current(col.index('井号'))
            self.P_cl_3.current(col.index('日产油量'))
        except:
            self.P_cl_1.current(0)
            self.P_cl_2.current(0)
            self.P_cl_3.current(0)
        self.validate_command['state'] = tkinter.NORMAL
        self.lag_command['state'] = tkinter.NORMAL
        self.predict_command['state'] = tkinter.NORMAL

    def read_csv_I(self, ):
        '''
        读取注入井报告数据,若其中包含年月,井号,日注入量等表头则设为默认表头
        :return: 原始注入井报告数据
        '''
        from util import _read
        self.Idata = _read()
        col = list(self.Idata.columns)
        self.I_cl_1['values'] = col
        self.I_cl_2['values'] = col
        self.I_cl_3['values'] = col
        try:
            self.I_cl_1.current(col.index('年月'))
            self.I_cl_2.current(col.index('井号'))
            self.I_cl_3.current(col.index('日注入量'))
        except:
            self.I_cl_1.current(0)
            self.I_cl_2.current(0)
            self.I_cl_3.current(0)

    def data_prepro(self):
        '''
        该方法将油田的日报/月报数据转换为日期/井号格式的表格数据
        :return: 日期/井号格式的表格数据
        '''
        m_assert_error(self.Pdata is not None, '未读取采出井数据')
        m_assert_error(self.P_cl_1.get(), '未选取采出井年月表头')
        m_assert_error(self.P_cl_2.get(), '未选取采出井井号表头')
        m_assert_error(self.P_cl_3.get(), '未选取采出井流量表头')
        np.random.seed(1)
        Pdata = self.Pdata.sort_values(by=self.P_cl_1.get())
        Pdata.loc[Pdata[self.P_cl_3.get()] < 0, self.P_cl_3.get()] = 0
        Ptimeseries = Pdata.pivot_table(columns=self.P_cl_2.get(), index=self.P_cl_1.get(),
                                        values=self.P_cl_3.get(), fill_value=0)
        Ptimeseries.columns = ['%s_prod' % c for c in Ptimeseries.columns]
        if self.v2.get() == 1:
            m_assert_error(self.Idata is not None, '未读取注入井数据')
            m_assert_error(self.I_cl_1.get(), '未选取注入井年月表头')
            m_assert_error(self.I_cl_2.get(), '未选取注入井井号表头')
            m_assert_error(self.I_cl_3.get(), '未选取注入井流量表头')

            Idata = self.Idata.sort_values(by=self.I_cl_1.get(), )
            Idata.loc[Idata[self.I_cl_3.get()] < 0, self.I_cl_3.get()] = 0
            Itimeseries = Idata.pivot_table(columns=self.I_cl_2.get(), index=self.I_cl_1.get(),
                                            values=self.I_cl_3.get(), fill_value=0)
            Itimeseries.columns = ['%s_inj' % c for c in Itimeseries.columns]
            I_mintime = min(Idata[self.I_cl_1.get()])
            P_mintime = min(Pdata[self.P_cl_1.get()])
            if I_mintime > P_mintime:
                skip_i = list(Ptimeseries.index).index(I_mintime)
                Ptimeseries = Ptimeseries[skip_i:]
            else:
                skip_i = list(Itimeseries.index).index(P_mintime)
                Itimeseries = Itimeseries[skip_i:]
            self.total = pd.concat((Itimeseries, Ptimeseries), axis=1)

            self.total.index = pd.to_datetime(self.total.index.astype(str), format='%Y%m')
            self.total_mean = self.total.rolling(window=4).mean()[4:]
            self.pcol_num = np.array([list(self.total.columns).index(c) for c in self.total.columns if 'prod' in c])
            self.icol_num = np.array([list(self.total.columns).index(c) for c in self.total.columns if 'inj' in c])
        else:
            self.total = Ptimeseries
            self.total.index = pd.to_datetime(self.total.index.astype(str), format='%Y%m')
            self.total_mean = self.total.rolling(window=4).mean()[4:]
            self.pcol_num = np.array([list(self.total.columns).index(c) for c in self.total.columns if 'prod' in c])
        self.skip_i = int(self.year_cl.get())
        m_assert_error(self.skip_i < len(self.total) - self.total.shape[1], '跳过步数必须小于时间步数')

        self.maxlags = int(self.Lag_cl.get())

    def prepare_Y(self, skip_i, part_i):
        '''
        该方法为预处理步骤，包括log1p化及平滑化
        :param skip_i: 跳过的时间步长数
        :param part_i: 若是验证模型，则该值默认为n-10,预测则为n
        :return:
        '''
        Y_endog = self.total_mean[skip_i:part_i].iloc[:, self.pcol_num]
        Y_endog = pd.DataFrame(np.log1p(Y_endog), columns=Y_endog.columns, index=Y_endog.index)
        Y_endog += np.random.rand(*Y_endog.shape) / 1e10
        Y_future = self.total_mean[part_i:].iloc[:, self.pcol_num]
        if self.v2.get():
            Y_exog = np.log1p(self.total_mean[skip_i:part_i].iloc[:, self.icol_num])
            Y_exog += np.random.rand(*Y_exog.shape) / 1e10
            Y_exog_future = np.log1p(self.total_mean[part_i:].iloc[:, self.icol_num])
            Y_exog_future += np.random.rand(*Y_exog_future.shape) / 1e10
        else:
            Y_exog = None
            Y_exog_future = None
        return Y_endog, Y_future, Y_exog, Y_exog_future

    def maxlag_selection(self):
        '''
        最大滞后阶数选择
        :return: 不同准则下最优滞后阶数
        '''

        def get_ic_table(ics, selected_orders):
            '''
            该方法将滞后阶数结果转换为表格化的分析结果
            :param ics: 滞后阶数结果
            :param selected_orders: 最大滞后阶数
            :return: 返回表格化的滞后阶数分析结果
            '''
            _default_table_fmt = dict(
                empty_cell='',
                colsep='  ',
                row_pre='',
                row_post='',
                table_dec_above='=',
                table_dec_below='=',
                header_dec_below='-',
                header_fmt='%s',
                stub_fmt='%s',
                title_align='c',
                header_align='r',
                data_aligns='r',
                stubs_align='l',
                fmt='txt'
            )
            cols = sorted(ics)
            data = np.array([["%#10.4g" % v for v in ics[c]] for c in cols],
                            dtype=object).T
            for i, col in enumerate(cols):
                idx = int(selected_orders[col]), i
                data[idx] = data[idx] + '*'
            fmt = dict(_default_table_fmt,
                       data_fmts=("%s",) * len(cols))
            buf = StringIO()
            table = SimpleTable(data, cols, lrange(len(data)),
                                title='VAR Order Selection', txt_fmt=fmt)
            buf.write(str(table) + '\n')
            buf.write('* Minimum' + '\n')
            return buf.getvalue()

        self.data_prepro()

        Y, Y_future, Y_exog, Y_exog_future = self.prepare_Y(self.skip_i, -10)

        model = VAR(endog=Y, exog=Y_exog)
        ics = defaultdict(list)
        for p in range(self.maxlags + 1):
            result = model._estimate_var(p, offset=self.maxlags - p)
            for k, v in iteritems(result.info_criteria):
                ics[k].append(v)
        selected_orders = dict((k, np.array(v).argmin())
                               for k, v in iteritems(ics))
        t_str = get_ic_table(ics, selected_orders)
        t_str += '\n%s' % str(selected_orders)
        self.model = model
        self.InfoText.delete(0.0, tkinter.END)
        self.InfoText.insert(0.0, t_str)

    def fit_and_validate(self, ):
        from m_VAR import m_VAR_model
        '''
        拟合并验证
        :return:
        '''
        self.data_prepro()
        steps_valid = 10
        Y_valid, Y_future, Y_exog, Y_exog_future = self.prepare_Y(self.skip_i, -steps_valid)
        # model = VAR(endog=Y_valid, exog=Y_exog)
        # self.result = model.fit(maxlags=self.maxlags,)
        # self.model = model
        model = m_VAR_model(Y_valid, exog=Y_exog, maxlags=self.maxlags)
        model.fit()
        # y_pred = np.exp(self.result.forecast(np.array(Y_valid), steps_valid, exog_future=Y_exog_future)) - 1
        y_pred = np.exp(model.forecast(Y_valid, steps_valid, exog_future=Y_exog_future, forecast_cov=True)) - 1
        y_pred[np.isnan(y_pred)] = 0
        y_pred[np.isinf(y_pred)] = 0
        score = mean_absolute_error(y_pred=y_pred, y_true=self.total_mean[-steps_valid:].values[:, self.pcol_num])
        self.verbose_list.insert(0, '滞后阶数:%d, 考虑注入井:%d, mae:%.6f' % (int(self.Lag_cl.get()), self.v2.get(), score))

        if self.v3.get():
            point_forecast, forc_lower, forc_upper = forecast_interval(Y_valid.values, self.result.coefs,
                                                                       self.result.coefs_exog.T, self.result.sigma_u,
                                                                       steps=steps_valid, exog=np.column_stack(
                    [np.ones((steps_valid, 1)), Y_exog_future]))
            self.validate_window = m_forecast_plot_window(Y_valid, Y_future, y_pred, fore_cov=(forc_lower, forc_upper))
        else:
            self.validate_window = m_forecast_plot_window(Y_valid, Y_future, y_pred, )

    def fit_and_predict(self, ):
        pass
        '''
        拟合并预测
        :return:
        '''
        # self.data_prepro()
        # Y, Y_future, Y_exog, Y_exog_future = self.prepare_Y(self.skip_i, -10)
        # model = VAR(endog=Y, exog=Y_exog)
        # self.result = model.fit(maxlags=self.maxlags)
        # self.model = model
        # y_pred = np.exp(self.result.forecast(model.y, steps=10, exog_future=Y_exog_future).clip(0, 10000)) - 1

    def m_irf(self):
        '''
        拟合完成后，进行脉冲响应分析可对注水井进行评价
        :return: 脉冲响应分析窗口
        '''
        m_assert_error(self.model is not None, '需要才可进行脉冲响应分析')
        m_assert_error(self.result is not None, '模型拟合后才可进行脉冲响应分析')
        m_assert_error(self.icol_num is not None, '脉冲响应分析需要输入注入井数据')
        self.irf_window = m_irf_window(self.model, self.result, self.total_mean, self.pcol_num, self.icol_num)


class m_irf_window:
    '''
    脉冲响应窗口
    '''

    def __init__(self, model, results, total, p_col_num, i_col_num):
        '''
        脉冲响应窗口初始化函数
        :param model: VAR模型
        :param results: VAR拟合结果
        :param total: 表格化数据体
        :param p_col_num: 采出井索引
        :param i_col_num: 注入井索引
        '''
        self.model = model
        self.results = results
        self.total = total
        self.z = self.results.ys_lagged
        self.sigma_u = self.results.sigma_u
        self.p_col_num = p_col_num
        self.i_col_num = i_col_num
        self.periods = 10

        self.root = tkinter.Tk()
        self.root.title('脉冲响应分析')
        self.root.geometry('250x220')

        tkinter.Label(self.root, text='采出井号').grid(row=0)
        self.cl_1 = ttk.Combobox(self.root, )
        self.cl_1.grid(row=1)

        # self.cl_1['values'] = ['所有'] + list(self.total.columns[self.p_col_num])
        self.cl_1['values'] = ['所有'] + ['present_' + c if self.total[c].iloc[-1] > 0.01 else c for c in
                                        self.total.columns[self.p_col_num]]

        self.cl_1.current(0)
        self.cl_1['state'] = 'readonly'
        for i, c in enumerate(self.total.columns[self.p_col_num]):
            if self.total[c].iloc[-1] > 0.01:
                self.cl_1.rowconfigure(0, {'weight': 3})

        tkinter.Label(self.root, text='注入井号').grid(row=2)
        self.cl_2 = ttk.Combobox(self.root, )
        self.cl_2.grid(row=3)
        # self.cl_2['values'] = ['所有'] + list(self.total.columns[self.i_col_num])
        self.cl_2['values'] = ['所有'] + ['present_' + c if self.total[c].iloc[-1] > 0.01 else c for c in
                                        self.total.columns[self.i_col_num]]
        self.cl_2.current(0)
        self.cl_2['state'] = 'readonly'
        for i, c in enumerate(self.total.columns[self.i_col_num]):
            if self.total[c].iloc[-1] > 0.01:
                self.cl_2.rowconfigure(0, {'weight': 3})

        self.max_n = 10
        self.phis = self.exog_irf(self.results, self.max_n)
        self.stderr = None

        tkinter.Button(self.root, text='作图', command=self.plot).grid(row=4)

        self.v = tkinter.IntVar()
        self.v.set(0)
        tkinter.Checkbutton(self.root, text='计算不确定性', variable=self.v, ).grid(row=5, sticky=tkinter.W)
        self.canvas = tkinter.Canvas(self.root, width=170, height=26, bg="white")
        self.canvas.grid(row=6)
        self.fill_line = self.canvas.create_rectangle(2, 2, 0, 27, width=0, fill="blue")
        self.process_vs = tkinter.StringVar()
        self.process_vs.set('')
        self.process_vl = tkinter.Label(self.root, fg='blue', textvariable=self.process_vs)
        self.process_vl.grid(row=7)

        self.root.mainloop()

    def exog_irf(self, results, max_n):
        '''
        计算脉冲响应期望均值函数
        :param results: VAR拟合结果
        :param max_n: 最大脉冲影响阶数
        :return: 脉冲影响矩阵
        '''
        results = self.results
        p, k, k = results.coefs.shape
        k_i = results.coefs_exog.shape[1]
        phis = np.zeros((self.max_n + 1, k, k_i))
        phis[0] = np.dot(np.eye(k), results.coefs_exog)
        for i in range(1, self.max_n + 1):
            for j in range(1, i + 1):
                if j > p:
                    break
                phis[i] += np.dot(results.coefs[j - 1], phis[i - j])
        return phis

    def process_bar(self, x, i):
        '''
        进度条
        :param x: 最大循环次数
        :param i: 当前循环次数
        :return:
        '''
        n = i * 180 / x
        self.canvas.coords(self.fill_line, (0, 0, n, 30))
        self.process_vs.set(str(round(i + 1 / x, 1)) + "%")
        self.root.update()

    def plot(self):
        '''
        绘制脉冲响应图,目前的不确定性分析尚未完成
        :return:
        '''
        resp_name = self.cl_1.get()
        imp_name = self.cl_2.get()

        if resp_name == '所有' and imp_name == '所有':
            tkinter.messagebox.showerror('错误', '不能同时选择所有注入井及采出井')
            raise RuntimeError
        elif resp_name == '所有':
            j = self.cl_2['values'].index(imp_name) - 1
            fig, ax = plt.subplots()
            plt.plot(np.arange(self.phis.shape[0]), self.phis[:, :, j + 1].sum(axis=1))
            plt.title(r'%s$\rightarrow$%s' % (re.sub('present_', '', imp_name), '所有'), fontsize=20)
            plt.xlabel('滞后阶数', fontsize=15)
            plt.xticks(fontsize=15)
            plt.yticks(fontsize=15)
        elif imp_name == '所有':
            i = self.cl_1['values'].index(resp_name) - 1
            fig, ax = plt.subplots()
            plt.plot(np.arange(self.phis.shape[0]), self.phis[:, i, :].sum(axis=1))
            plt.title(r'%s$\rightarrow$%s' % ('所有', re.sub('present_', '', resp_name)), fontsize=20)
            plt.xlabel('滞后阶数', fontsize=15)
            plt.xticks(fontsize=15)
            plt.yticks(fontsize=15)
        else:
            i = self.cl_1['values'].index(resp_name)
            j = self.cl_2['values'].index(imp_name)
            fig, ax = plt.subplots()
            plt.plot(np.arange(self.phis.shape[0]), self.phis[:, i, j + 1])
            plt.title(r'%s$\rightarrow$%s' % (re.sub('present_', '', resp_name), re.sub('present_', '', imp_name)),
                      fontsize=20)
            plt.xlabel('滞后阶数', fontsize=15)
            plt.xticks(fontsize=15)
            plt.yticks(fontsize=15)

            if self.v.get() == 1:
                if self.stderr is None:
                    self.stderr = self._compute_std()
                plt.fill_between(np.arange(self.phis.shape[0]),
                                 self.phis[:, i, j] + self.stderr[0][:, i, j],
                                 self.phis[:, i, j] - self.stderr[1][:, i, j], alpha=0.2)
        plt.show()

    def _compute_std(self, repl=100, signif=0.05, burn=100, cum=False, ):
        '''
        不确定性分析函数
        :param repl:
        :param signif:
        :param burn:
        :param cum:
        :return:
        '''
        ex_neqs = self.results.coefs_exog.shape[1]
        neqs = self.results.neqs
        k_ar = self.results.k_ar
        coefs = self.results.coefs
        sigma_u = self.sigma_u
        intercept = self.results.intercept
        nobs = self.results.nobs

        ma_coll = np.zeros((repl, self.max_n + 1, neqs, ex_neqs))

        def fill_coll(sim):
            ret = VAR(sim, exog=self.model.exog[-nobs:]).fit(maxlags=k_ar, )
            ret = self.exog_irf(self.results, self.max_n)
            return ret.cumsum(axis=0) if cum else ret

        for i in tqdm.tqdm(range(repl)):
            sim = util.varsim(coefs, intercept, sigma_u,
                              seed=None, steps=nobs + burn)
            sim = sim[burn:]
            ma_coll[i, :, :, :] = fill_coll(sim)
            self.process_bar(repl, i)

        ma_sort = np.sort(ma_coll, axis=0)  # sort to get quantiles
        low_idx = int(round(signif / 2 * repl) - 1)
        upp_idx = int(round((1 - signif / 2) * repl) - 1)
        lower = ma_sort[low_idx, :, :, :]
        upper = ma_sort[upp_idx, :, :, :]
        return lower, upper


class m_forecast_plot_window:
    '''
    预测图绘制窗口
    '''

    def __init__(self, Y_endog, Y_future, Y_pred, fore_cov=None):
        '''
        预测图绘制窗口初始化函数
        :param Y_endog: 训练用数据
        :param Y_future: 待预测数据
        :param Y_pred: 预测结果
        :param result: 拟合结果数据体
        '''
        self.Y_endog = Y_endog
        self.Y_future = Y_future
        self.Y_pred = Y_pred
        self.fore_cov = fore_cov
        self.root = tkinter.Tk()
        self.root.title('预测图形绘制')
        self.root.geometry('225x300')
        self.prod_lb = tkinter.Listbox(self.root, selectmode=tkinter.MULTIPLE)
        for c in Y_endog.columns:
            self.prod_lb.insert(tkinter.END, c)
        for i, c in enumerate(Y_endog.columns):
            if Y_endog[c].iloc[-1] < 1e-10:
                self.prod_lb.itemconfig(i, {'fg': 'grey'})
        self.prod_lb.grid()
        self.prod_lb_scroll = tkinter.Scrollbar(self.root, command=self.prod_lb.yview)
        self.prod_lb_scroll.grid(row=0, column=1, sticky='ns')
        self.prod_lb.config(yscrollcommand=self.prod_lb_scroll)
        self.prod_lb.selection_set(0)

        tkinter.Label(self.root, text='灰色为近期未投产的井', fg='blue').grid(row=1, column=0, columnspan=2)
        tkinter.Button(self.root, text='作图', command=self.plot).grid(row=2, column=0)

        # forecast_interval(Y_endog, self.result.coefs,self.result.exog_coefs, self.result.sigma_u, steps=)
        self.root.mainloop()

    def plot(self):
        '''
        绘图函数
        :return:
        '''
        sl = self.prod_lb.curselection()
        try:
            assert len(sl) > 0
        except:
            tkinter.messagebox.showerror('错误', '必须选中至少一口井')
            raise RuntimeError
        w_name = [self.prod_lb.get(i) for i in sl] if len(sl) > 1 else [self.prod_lb.get(sl)]
        w_num = [list(self.Y_endog.columns).index(c) for c in w_name]

        c_b = ['r', 'b', 'c', 'g', 'y', 'k', 'm']
        fig, ax = plt.subplots()
        i_ = 0
        for i_, i in enumerate(w_num):
            c = w_name[i_]
            plt.plot(self.Y_endog.index, self.Y_endog[c], c_b[i_ % 7] + '.', label='%s原始' % c)
            plt.plot(self.Y_future.index, self.Y_pred[:, i], c_b[i_ % 7] + '-', label='%s预测' % c)
            plt.plot(self.Y_future.index, self.Y_future[c], c_b[i_ % 7] + 'x', label='%s实际' % c)
            if self.fore_cov is not None:
                forc_lower, forc_upper = self.fore_cov
                plt.fill_between(self.Y_future.index, forc_lower[:, i], forc_upper[:, i], label='%s不确定范围' % c)
        plt.legend(loc='best', fontsize=15)
        plt.xlabel('时间', fontsize=15)
        plt.ylabel('日采出量/(m^3/d)', fontsize=15)
        plt.xticks(fontsize=15, rotation=75)
        plt.yticks(fontsize=15)
        plt.show()


if __name__ == "__main__":
    win = window()



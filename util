import numpy as np
import pandas as pd
from functools import reduce
import tkinter
import scipy.stats as stats
from tkinter import messagebox
from tkinter import filedialog

def input_check(x):
    assert isinstance(x, (np.ndarray, pd.DataFrame, list)), 'input type must be in [ndarray, DataFrame, list]'
    if isinstance(x, list):
        x = np.array(x)
        assert x.dtype == np.float or x.dtype == np.int, 'input must be able to transform into num ndarray'
        assert len(x.shape) > 1 and x.shape[1] > 1, 'input must have multi variables'
    elif isinstance(x, np.ndarray):
        assert x.dtype == np.float or x.dtype == np.int, 'input dtype must be num'
        assert len(x.shape) > 1 and x.shape[1] > 1, 'input must have multi variables'
    else:
        assert all(i == np.float or i == np.int for i in x.dtypes), 'input dtype must be num'
        assert len(x.shape) > 1 and x.shape[1] > 1, 'input must have multi variables'


def num_check(x):
    assert isinstance(x, (float, int)), 'input must be num'

def chain_dot(*X):
    X=X[::-1]
    return reduce(np.dot,X)
def _read():
    '''
    读取逻辑及异常逻辑
    :return: 读取结果
    '''
    file_path = filedialog.askopenfilename()
    try:
        suffix = file_path.split('.')[-1]
    except:
        tkinter.messagebox.showerror('错误', '读取失败')
        raise RuntimeError
    if suffix == 'csv':
        try:
            data = pd.read_csv(file_path)
        except UnicodeDecodeError:
            data = pd.read_csv(file_path, encoding='gbk')
        except OSError:
            try:
                data = pd.read_csv(file_path, encoding='gbk', engine='python')
            except OSError:
                tkinter.messagebox.showerror('错误', '读取了错误的文件')
                raise OSError
    elif suffix == 'xlsx':
        try:
            data = pd.read_excel(file_path)
        except UnicodeDecodeError:
            data = pd.read_excel(file_path, encoding='gbk')
        except OSError:
            try:
                data = pd.read_excel(file_path, encoding='gbk', engine='python')
            except OSError:
                tkinter.messagebox.showerror('错误', '读取了错误的文件')
                raise OSError
    else:
        tkinter.messagebox.showerror('错误', '未知错误')
        raise RuntimeError
    return data
def m_assert_error(flag, name):
    '''
    断言/错误函数
    :param flag: 断言内容
    :param name: 错误显示内容
    :return:
    '''
    try:
        assert flag
    except:
        tkinter.messagebox.showerror('错误', name)
        raise RuntimeError

def ma_rep(coefs, maxn=10):
    r"""
    MA(\infty) representation of VAR(p) process

    Parameters
    ----------
    coefs : ndarray (p x k x k)
    maxn : int
        Number of MA matrices to compute

    Notes
    -----
    VAR(p) process as

    .. math:: y_t = A_1 y_{t-1} + \ldots + A_p y_{t-p} + u_t

    can be equivalently represented as

    .. math:: y_t = \mu + \sum_{i=0}^\infty \Phi_i u_{t-i}

    e.g. can recursively compute the \Phi_i matrices with \Phi_0 = I_k

    Returns
    -------
    phis : ndarray (maxn + 1 x k x k)
    """
    p, k, k = coefs.shape
    phis = np.zeros((maxn+1, k, k))
    phis[0] = np.eye(k)

    # recursively compute Phi matrices
    for i in range(1, maxn + 1):
        for j in range(1, i+1):
            if j > p:
                break

            phis[i] += np.dot(phis[i-j], coefs[j-1])

    return phis
def forecast_cov(ma_coefs, sigma_u, steps):
    """
    Compute theoretical forecast error variance matrices

    Parameters
    ----------
    steps : int
        Number of steps ahead

    Notes
    -----
    .. math:: \mathrm{MSE}(h) = \sum_{i=0}^{h-1} \Phi \Sigma_u \Phi^T

    Returns
    -------
    forc_covs : ndarray (steps x neqs x neqs)
    """
    neqs = len(sigma_u)
    forc_covs = np.zeros((steps, neqs, neqs))

    prior = np.zeros((neqs, neqs))
    for h in range(steps):
        # Sigma(h) = Sigma(h-1) + Phi Sig_u Phi'
        phi = ma_coefs[h]
        var = chain_dot(phi, sigma_u, phi.T)
        forc_covs[h] = prior = prior + var

    return forc_covs



def forecast(y, coefs, trend_coefs, steps, exog=None):
    """
    Produce linear minimum MSE forecast

    Parameters
    ----------
    y : ndarray (k_ar x neqs)
    coefs : ndarray (k_ar x neqs x neqs)
    trend_coefs : ndarray (1 x neqs) or (neqs)
    steps : int
    exog : ndarray (trend_coefs.shape[1] x neqs)

    Returns
    -------
    forecasts : ndarray (steps x neqs)

    Notes
    -----
    Lütkepohl p. 37

    Also used by DynamicVAR class
    """
    p = len(coefs)
    k = len(coefs[0])
    # initial value
    forcs = np.zeros((steps, k))
    if exog is not None and trend_coefs is not None:
        forcs += np.dot(exog, trend_coefs)
    # to make existing code (with trend_coefs=intercept and without exog) work:
    elif exog is None and trend_coefs is not None:
        forcs += trend_coefs

    # h=0 forecast should be latest observation
    # forcs[0] = y[-1]

    # make indices easier to think about
    for h in range(1, steps + 1):
        # y_t(h) = intercept + sum_1^p A_i y_t_(h-i)
        f = forcs[h - 1]
        for i in range(1, p + 1):
            # slightly hackish
            if h - i <= 0:
                # e.g. when h=1, h-1 = 0, which is y[-1]
                prior_y = y[h - i - 1]
            else:
                # e.g. when h=2, h-1=1, which is forcs[0]
                prior_y = forcs[h - i - 1]

            # i=1 is coefs[0]
            f = f + np.dot(coefs[i - 1], prior_y)

        forcs[h - 1] = f

    return forcs

def _forecast_vars(steps, ma_coefs, sig_u):
    """_forecast_vars function used by VECMResults. Note that the definition
    of the local variable covs is the same as in VARProcess and as such it
    differs from the one in VARResults!

    Parameters
    ----------
    steps
    ma_coefs
    sig_u

    Returns
    -------

    """
    covs = forecast_cov(ma_coefs, sig_u, steps)
    # Take diagonal for each cov
    neqs = len(sig_u)
    inds = np.arange(neqs)
    return covs[:, inds, inds]



def forecast_interval(y, coefs, trend_coefs, sig_u, steps=5, alpha=0.05,
                      exog=1):
    assert(0 < alpha < 1)
    q = norm_signif_level(alpha)

    point_forecast = forecast(y, coefs, trend_coefs, steps, exog)
    ma_coefs = ma_rep(coefs, steps)
    sigma = np.sqrt(_forecast_vars(steps, ma_coefs, sig_u))

    forc_lower = point_forecast - q * sigma
    forc_upper = point_forecast + q * sigma

    return point_forecast, forc_lower, forc_upper

def norm_signif_level(alpha=0.05):
    return stats.norm.ppf(1 - alpha / 2)
